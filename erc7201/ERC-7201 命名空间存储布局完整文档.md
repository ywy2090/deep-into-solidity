
# ERC-7201: 命名空间存储布局

**Standards Track: ERC**

## 基本信息

- **标题**: 命名空间存储模式中结构体存储位置的约定
- **作者**: 
  - Francisco Giordano ([@frangio](https://github.com/frangio))
  - Hadrien Croubois ([@Amxx](https://github.com/Amxx))
  - Ernesto García ([@ernestognw](https://github.com/ernestognw))
  - Eric Lau ([@ericglau](https://github.com/ericglau))
- **创建时间**: 2023-06-20
- **状态**: Standards Track

---

## 摘要

我们定义 NatSpec 注解 `@custom:storage-location`，以记录 Solidity 或 Vyper 源代码中存储命名空间及其在存储中的位置。此外，我们定义了一个公式，用于从任意标识符派生位置。选择该公式是为了安全地防止与 Solidity 和 Vyper 使用的存储布局发生冲突。

---

## 动机

### 传统存储布局的挑战

智能合约语言（如 Solidity 和 Vyper）依赖于**树形存储布局**。这棵树从插槽 0 开始，由连续变量的连续块组成。哈希用于确保包含映射和动态数组的值的块不发生冲突。

这对于大多数合约来说已经足够了。然而，它给智能合约开发中使用的各种设计模式带来了挑战：

1. **模块化设计**: 使用 `DELEGATECALL`，一个合约执行来自多个合约的代码，所有这些合约共享相同的存储空间，并且必须仔细协调如何使用它。

2. **可升级合约**: 在升级中很难添加状态变量，因为它们可能会影响预先存在变量的分配存储位置。

### 解决方案

这些模式可以受益于跨存储空间布局状态变量，而不是使用此默认存储布局，通常是在通过哈希获得的**伪随机位置**。

- 每个值可以放置在完全不同的位置
- 更常见的是，一起使用的值会放入 Solidity 结构体中，并共同位于存储中
- 这些伪随机位置可以是新存储树的根，这些树遵循与默认存储树相同的规则
- 如果构建此伪随机根以使其不属于默认树的一部分，则应导致定义不相互冲突或与默认存储不冲突的独立空间

### 标准化的必要性

这些存储使用模式对于 Solidity 和 Vyper 编译器是不可见的，因为它们未表示为 Solidity 状态变量。静态分析器或区块链浏览器等智能合约工具通常需要知道合约数据的存储位置。**标准化存储布局的位置将允许这些工具正确解释使用这些设计模式的合约**。

---

## 规范

### 预备知识

**命名空间 (Namespace)**: 由一组有序变量组成，其中一些变量可能是动态数组或映射，它们的值按照与默认存储布局相同的规则进行布局，但根位于不一定是插槽 0 的某个位置。

**命名空间存储 (Namespaced Storage)**: 使用命名空间来组织存储的合约被称为使用命名空间存储。

**命名空间 ID (Namespace ID)**: 一个字符串，用于标识合约中的命名空间。它不应包含任何空格字符。

### `@custom:storage-location` 注解

合约中的命名空间应**实现为结构体类型**。这些结构体应使用 NatSpec 标记进行注释：

```
@custom:storage-location <FORMULA_ID>:<NAMESPACE_ID>
```

其中：
- `<FORMULA_ID>`: 标识用于计算命名空间的根存储位置的公式
- `<NAMESPACE_ID>`: 标识具体的命名空间

> **注意**: Solidity 编译器从 v0.8.20 开始在 AST 中包含此注释，因此建议将其作为使用此模式时的最低编译器版本。

在合约外部找到的带有此注释的结构体不被视为源代码中任何合约的命名空间。

### `erc7201` 公式

由 `erc7201` 标识的公式定义为：

```
erc7201(id: string) = keccak256(keccak256(id) - 1) & ~0xff
```

**Solidity 实现**:
```solidity
keccak256(abi.encode(uint256(keccak256(bytes(id))) - 1)) & ~bytes32(uint256(0xff))
```

**使用示例**:
```
@custom:storage-location erc7201:<NAMESPACE_ID>
```

例如，`@custom:storage-location erc7201:foobar` 注释了一个 id 为 `"foobar"` 的命名空间，该命名空间以 `erc7201("foobar")` 为根。

### 未来扩展

未来的 EIP 可能会定义带有唯一公式标识符的新公式。建议遵循此 EIP 中设置的约定，并使用 `erc1234` 格式的标识符。

---

## 原理

### 存储布局语法

Solidity 和 Vyper 使用的树形存储布局遵循以下语法（其中 root=0）：

```
L_root := root | L_root + n | keccak256(L_root) | keccak256(H(k) ⊕ L_root) | keccak256(L_root ⊕ H(k))
```

### 公式设计原理

**根的要求**: 它不应与属于 Solidity 和 Vyper 使用的标准存储树（root = 0）的任何存储位置重叠，也不应属于从任何其他命名空间（另一个根）派生的存储树的一部分。

**为什么选择 `keccak256(keccak256(id) - 1) & ~0xff`**:

1. **第一步 `keccak256(id) - 1`**: 选择为 Solidity 未使用的位置

2. **第二步 `keccak256(...)`**: 
   - `keccak256(id) - 1` 不直接用作最终位置，因为命名空间可能大于 1 个插槽
   - 会扩展到 `keccak256(id) + n` 中，这可能会被 Solidity 使用
   - 添加第二个哈希以防止这种情况，保证命名空间与标准存储完全不相交
   - 假设 keccak256 抗冲突且数组不太大

3. **第三步 `& ~0xff` (与 256 对齐)**:
   - 作为潜在的优化
   - 预期 Verkle 状态树迁移后的 gas 计划更改
   - 这可能会导致 256 个存储插槽的组一次全部变热

### 命名

此模式有时被称为"**钻石存储**"（Diamond Storage）。这导致它与"钻石代理模式"（Diamond Proxy Pattern）混淆，即使它们可以彼此独立使用。此 EIP 选择使用不同的名称（命名空间存储），以将其与代理模式清楚地区分开来。

---

## 参考实现

```solidity
pragma solidity ^0.8.20;

contract Example {
    /// @custom:storage-location erc7201:example.main
    struct MainStorage {
        uint256 x;
        uint256 y;
    }

    // keccak256(abi.encode(uint256(keccak256("example.main")) - 1)) & ~bytes32(uint256(0xff));
    bytes32 private constant MAIN_STORAGE_LOCATION =
        0x183a6125c38840424c4a85fa12bab2ab606c4b6d0e7cc73c0c06ba5300eab500;

    function _getMainStorage() private pure returns (MainStorage storage $) {
        assembly {
            $.slot := MAIN_STORAGE_LOCATION
        }
    }

    function _getXTimesY() internal view returns (uint256) {
        MainStorage storage $ = _getMainStorage();
        return $.x * $.y;
    }
}
```

### 代码说明

1. **定义命名空间结构体**: 使用 `@custom:storage-location` 注解标记
2. **计算存储位置**: 使用 `erc7201` 公式计算并声明为常量
3. **获取存储引用**: 通过汇编代码将计算出的位置赋值给结构体的存储指针
4. **使用命名空间**: 通过获取存储引用来读写命名空间中的变量

---

## 向后兼容性

未发现向后兼容性问题。

---

## 安全注意事项

### 避免冲突

命名空间应避免与其他命名空间或标准 Solidity 或 Vyper 存储布局发生冲突。在 **keccak256 抗冲突的假设下**，此 ERC 中定义的公式保证了任意命名空间 id 的此属性。

### 开发者责任

`@custom:storage-location` 是一个 NatSpec 注解，当前编译器不对其强制执行任何规则或赋予任何含义。**合约开发人员负责实现该模式并按照注解中的声明使用命名空间**。

---

## 版权

版权及相关权利通过 [CC0](https://creativecommons.org/publicdomain/zero/1.0/) 放弃。

---

## 引用格式

Francisco Giordano ([@frangio](https://github.com/frangio)), Hadrien Croubois ([@Amxx](https://github.com/Amxx)), Ernesto García ([@ernestognw](https://github.com/ernestognw)), Eric Lau ([@ericglau](https://github.com/ericglau)), "ERC-7201: 命名空间存储布局," _Ethereum Improvement Proposals_, no. 7201, June 2023. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-7201.
