
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @dev 这是一个帮助编写可升级合约或任何将部署在代理后面的合约的基础合约。
 * 由于代理合约不能有构造函数，因此通常将构造函数逻辑移至外部初始化函数，
 * 通常称为 `initialize`。因此，需要保护此初始化函数，使其只能调用一次。
 * 由此合约提供的 `initializer` 修饰符将产生这种效果。
 *
 * 初始化函数使用版本号。一旦使用某个版本号，它就会被消耗，
 * 不能重复使用。此机制可防止每个"步骤"的重新执行，但允许创建新的初始化步骤，
 * 以防升级添加了需要初始化的模块。
 *
 * 例如：
 *
 * [.hljs-theme-light.nopadding]
 * ```solidity
 * contract MyToken is ERC20Upgradeable {
 *     function initialize() initializer public {
 *         __ERC20_init("MyToken", "MTK");
 *     }
 * }
 *
 * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
 *     function initializeV2() reinitializer(2) public {
 *         __ERC20Permit_init("MyToken");
 *     }
 * }
 * ```
 *
 * TIP: 为避免使初始化函数处于未调用状态，建议您在初始化合约时手动调用
 * 实现合约中的 {_disableInitializers} 函数：
 *
 * [.hljs-theme-light.nopadding]
 * ```solidity
 * /// @custom:oz-upgrades-unsafe-allow constructor
 * constructor() {
 *     _disableInitializers();
 * }
 * ```
 */
abstract contract Initializable {
    /// @custom:storage-location erc7201:openzeppelin.storage.Initializable
    struct InitializableStorage {
        /**
         * @dev 指示合约是否已初始化。
         */
        uint64 _initialized;
        /**
         * @dev 指示合约当前是否正在初始化。
         */
        bool _initializing;
    }

    // keccak256(abi.encode(uint256(keccak256("openzeppelin.storage.Initializable")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant INITIALIZABLE_STORAGE = 
        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;

    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {
        assembly {
            $.slot := INITIALIZABLE_STORAGE
        }
    }

    /**
     * @dev 合约已初始化或正在初始化时触发。
     */
    event Initialized(uint64 version);

    /**
     * @dev 合约已经初始化时触发的错误。
     */
    error InvalidInitialization();

    /**
     * @dev 合约未初始化时触发的错误。
     */
    error NotInitializing();

    /**
     * @dev 触发一次性初始化函数的修饰符。
     * 它应该在合约的初始化函数上使用，该函数在设置时仅被调用一次。
     *
     * `initializer` 修饰符可以选择性地接受参数。
     *
     * 当使用继承时，可以安全地调用手动初始化函数，因为它们是幂等的。
     * 
     * 类似于 `reinitializer(1)`，但标记的函数不能嵌套。
     * 如果一个标记为 `initializer` 的函数直接或间接调用另一个 `initializer` 函数，
     * 执行将会回滚。
     *
     * 建议使用 {reinitializer(1)} 而非 `initializer`，因为前者更加灵活。
     */
    modifier initializer() {
        // 支持两种情况：
        // - 第一次初始化
        // - 正在构造（仅构造函数内部）
        InitializableStorage storage $ = _getInitializableStorage();

        // 将初始化标记为已完成，确保再次调用时会失败
        bool isTopLevelCall = !$._initializing;
        uint64 initialized = $._initialized;

        // 允许：
        // - 第一次初始化（initialized == 0 && !_initializing）
        // - 在构造函数中（isTopLevelCall && initialized == type(uint64).max）
        if (!(initialized == 0 && isTopLevelCall || initialized == type(uint64).max && !isTopLevelCall)) {
            revert InvalidInitialization();
        }
        $._initialized = 1;
        if (isTopLevelCall) {
            $._initializing = true;
        }
        _;
        if (isTopLevelCall) {
            $._initializing = false;
            emit Initialized(1);
        }
    }

    /**
     * @dev 保护重新初始化函数的修饰符，因此只能在特定版本号上调用一次。
     *
     * 与 `initializer` 不同，标记为 `reinitializer` 的函数可以嵌套在另一个 `initializer` 或 `reinitializer` 内。
     * 
     * 注意，在可升级合约的上下文中，版本基于 Initializable。然而，
     * 对于导致部署在代理后的合约（如最小克隆），这可能是任何部署模式的一部分，
     * 版本引用每个合约的部署数量，或者更确切地说，它从 0 开始，并在每次部署时递增。
     *
     * 警告：在构造函数中将版本设置为 2**64 - 1 将阻止通过重新初始化器进行任何未来的重新初始化。
     */
    modifier reinitializer(uint64 version) {
        InitializableStorage storage $ = _getInitializableStorage();

        if ($._initializing || $._initialized >= version) {
            revert InvalidInitialization();
        }
        $._initialized = version;
        $._initializing = true;
        _;
        $._initializing = false;
        emit Initialized(version);
    }

    /**
     * @dev 限制函数只能在初始化时调用的修饰符。
     */
    modifier onlyInitializing() {
        _checkInitializing();
        _;
    }

    /**
     * @dev 如果合约未初始化，则回滚。
     */
    function _checkInitializing() internal view virtual {
        if (!_isInitializing()) {
            revert NotInitializing();
        }
    }

    /**
     * @dev 锁定合约，阻止任何未来的重新初始化。此方法在初始化期间无法调用。
     * 建议在实现合约的构造函数中使用此方法。
     *
     * 发出 {Initialized} 事件，第一次使用此函数。
     */
    function _disableInitializers() internal virtual {
        InitializableStorage storage $ = _getInitializableStorage();

        if ($._initializing) {
            revert InvalidInitialization();
        }
        if ($._initialized != type(uint64).max) {
            $._initialized = type(uint64).max;
            emit Initialized(type(uint64).max);
        }
    }

    /**
     * @dev 返回合约当前是否正在初始化。参见 {onlyInitializing}。
     */
    function _isInitializing() internal view returns (bool) {
        return _getInitializableStorage()._initializing;
    }

    /**
     * @dev 返回已初始化的最高版本。参见 {reinitializer}。
     */
    function _getInitializedVersion() internal view returns (uint64) {
        return _getInitializableStorage()._initialized;
    }
}
