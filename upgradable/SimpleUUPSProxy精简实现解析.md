# UUPS 与透明代理（Transparent Proxy）的核心区别

在看代码之前，必须理解两者最大的区别：

- **透明代理**：升级逻辑（`upgradeTo`）写在 **代理合约（Proxy）** 里。  
- **UUPS**：升级逻辑（`upgradeTo`）写在 **逻辑合约（Implementation）** 里。

这意味着：在 UUPS 模式下，代理合约非常“轻量级”和“愚蠢”，它只负责转发。如果你的逻辑合约 V1 升级到 V2，而 V2 忘记写 `upgradeTo` 函数，你的代理合约就**永久无法升级了（变砖）**。

---

## UUPS 的工作流程详解

这部分逻辑比较绕，请按照以下步骤理解：

### 1. 部署阶段

- 你部署了 `LogicV1`。
- 你部署 `UUPSProxy`，并将 `LogicV1` 的地址告诉它。
- **注意**：`UUPSProxy` 本身**没有** `upgradeTo` 函数！

### 2. 调用阶段

当你调用代理合约的 `doSomething(20)`：

1. **代理合约**：我有这个函数吗？→ 没有。  
2. **Fallback**：转发给 `LogicV1`。  
3. **LogicV1**：在代理的存储中将 `val` 修改为 `20`。

### 3. 升级阶段（最神奇的地方）

你想升级到 `LogicV2`。

1. 你调用代理合约的 `upgradeTo(LogicV2_Address)`。  
2. **代理合约**：我有这个函数吗？→ **没有！**（这点最重要）。  
3. **Fallback**：转发给 `LogicV1`。  
4. **LogicV1**：我有这个函数吗？→ **有！**（继承自 `UUPSUpgradeable`）。  
5. `LogicV1` 执行 `upgradeTo`：
   - 检查 `msg.sender` 是否是 `owner`（权限控制）。
   - 修改存储槽：执行 `sstore(SLOT, LogicV2_Address)`。
6. **关键点**：因为是 `delegatecall`，虽然代码在 `LogicV1` 里，但**修改的是 `UUPSProxy` 的 Storage**。
7. 升级完成。下次调用时，代理去 Storage 里查地址，发现已经是 `LogicV2` 了。

---

## 对比总结

| 特性                 | UUPS                                      | 透明代理 (Transparent)                     |
| :------------------- | :---------------------------------------- | :----------------------------------------- |
| **Gas 成本 (部署)**  | **更低**（代理合约代码极少）              | 较高（代理合约包含升级和管理逻辑）         |
| **Gas 成本 (调用)**  | **更低**（没有 `ifAdmin` 检查）           | 每次调用都要检查是否是 Admin               |
| **升级逻辑位置**     | 在 **逻辑合约** 中                        | 在 **代理合约** 中                         |
| **安全性风险**       | **如果不小心删除了 `upgradeTo`，合约将永久无法升级** | 代理合约永远可以升级，逻辑合约坏了也能换   |
| **实现难度**         | 稍难（需要逻辑合约配合）                  | 简单（逻辑合约不需要关心代理）             |
